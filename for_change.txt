class RDPServer:
    def __init__(self, host='0.0.0.0', port=80):
        # Configuration
        self.REFRESH_RATE = 0.05
        self.SCROLL_SENSITIVITY = 5
        self.IMAGE_QUALITY = 95
        self.BUFFER_SIZE = 1024

        # Server setup
        self.host = (host, port)
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.socket.bind(self.host)
        self.socket.listen(1)
        
        # Add running flag and active connections tracking
        self.running = True
        self.active_connections = []
        self.active_threads = []

        # Image state
        self.last_image = None
        self.lock = threading.Lock()
        self.shift_pressed = False

    def start(self):
        """Start the RDP server and listen for connections"""
        print(f"Server started on {self.host[0]}:{self.host[1]}")
        
        # Set socket timeout to allow for clean shutdown
        self.socket.settimeout(1)
        
        while self.running:
            try:
                conn, addr = self.socket.accept()
                print(f"New connection from {addr}")
                
                # Track active connection
                self.active_connections.append(conn)
                
                # Create and track threads
                display_thread = threading.Thread(target=self.handle_display, args=(conn,))
                input_thread = threading.Thread(target=self.handle_input, args=(conn,))
                
                self.active_threads.extend([display_thread, input_thread])
                
                display_thread.start()
                input_thread.start()
                
            except socket.timeout:
                continue
            except Exception as e:
                if self.running:  # Only log if not stopping
                    print(f"Server error: {e}")
                break

    def handle_display(self, conn):
        """Handle screen capture and transmission"""
        try:
            # Initial screen capture and send
            initial_image = np.array(ImageGrab.grab())
            initial_image = cv2.cvtColor(initial_image, cv2.COLOR_RGB2BGR)
            _, image_bytes = cv2.imencode('.jpg', initial_image,
                                        [cv2.IMWRITE_JPEG_QUALITY, self.IMAGE_QUALITY])

            # Send initial frame
            header = struct.pack(">BI", 1, len(image_bytes))
            conn.sendall(header)
            conn.sendall(image_bytes)

            self.last_image = initial_image

            # Continuous screen update loop
            while self.running:  # Check running flag
                time.sleep(self.REFRESH_RATE)

                if not self.running:  # Check again after sleep
                    break

                # Capture new screen
                screen = np.array(ImageGrab.grab())
                screen = cv2.cvtColor(screen, cv2.COLOR_RGB2BGR)

                # Check for changes
                if np.array_equal(screen, self.last_image):
                    continue

                # Encode and send new frame
                _, frame_data = cv2.imencode('.jpg', screen,
                                           [cv2.IMWRITE_JPEG_QUALITY, self.IMAGE_QUALITY])

                header = struct.pack(">BI", 1, len(frame_data))
                conn.sendall(header)
                conn.sendall(frame_data)

                self.last_image = screen

        except Exception as e:
            print(f"Display handling error: {e}")
        finally:
            if conn in self.active_connections:
                self.active_connections.remove(conn)
            try:
                conn.close()
            except:
                pass

    def handle_input(self, conn):
        """Handle input events from client"""
        try:
            # Get client platform info
            platform = conn.recv(3)
            print(f"Client platform: {platform.decode()}")

            # Input event loop
            while self.running:  # Check running flag
                try:
                    event_data = conn.recv(6)
                    if not event_data or len(event_data) != 6:
                        break

                    key, action, x, y = struct.unpack('>BBHH', event_data)
                    self.process_input(key, action, x, y)
                except socket.timeout:
                    continue

        except Exception as e:
            print(f"Input handling error: {e}")
        finally:
            if conn in self.active_connections:
                self.active_connections.remove(conn)
            try:
                conn.close()
            except:
                pass

    def stop(self):
        """Stop the RDP server and clean up"""
        print("Stopping RDP server...")
        self.running = False
        
        # Close all active connections
        for conn in self.active_connections[:]:  # Use slice to avoid modification during iteration
            try:
                conn.close()
            except:
                pass
            self.active_connections.remove(conn)
        
        # Close server socket
        try:
            self.socket.close()
        except:
            pass
            
        # Wait for threads to finish
        for thread in self.active_threads:
            if thread.is_alive():
                thread.join(timeout=1.0)
        self.active_threads.clear()
        
        print("RDP server stopped successfully")
